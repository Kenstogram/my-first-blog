import copy
from collections import OrderedDict

<<<<<<< HEAD
from django.utils import six


class OrderedSet(object):
=======

class OrderedSet:
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
    """
    A set which keeps the ordering of the inserted items.
    Currently backs onto OrderedDict.
    """

    def __init__(self, iterable=None):
<<<<<<< HEAD
        self.dict = OrderedDict(((x, None) for x in iterable) if iterable else [])
=======
        self.dict = OrderedDict.fromkeys(iterable or ())
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435

    def add(self, item):
        self.dict[item] = None

    def remove(self, item):
        del self.dict[item]

    def discard(self, item):
        try:
            self.remove(item)
        except KeyError:
            pass

    def __iter__(self):
<<<<<<< HEAD
        return iter(self.dict.keys())
=======
        return iter(self.dict)
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435

    def __contains__(self, item):
        return item in self.dict

    def __bool__(self):
        return bool(self.dict)

<<<<<<< HEAD
    def __nonzero__(self):      # Python 2 compatibility
        return type(self).__bool__(self)

=======
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
    def __len__(self):
        return len(self.dict)


class MultiValueDictKeyError(KeyError):
    pass


class MultiValueDict(dict):
    """
    A subclass of dictionary customized to handle multiple values for the
    same key.

    >>> d = MultiValueDict({'name': ['Adrian', 'Simon'], 'position': ['Developer']})
    >>> d['name']
    'Simon'
    >>> d.getlist('name')
    ['Adrian', 'Simon']
    >>> d.getlist('doesnotexist')
    []
    >>> d.getlist('doesnotexist', ['Adrian', 'Simon'])
    ['Adrian', 'Simon']
    >>> d.get('lastname', 'nonexistent')
    'nonexistent'
    >>> d.setlist('lastname', ['Holovaty', 'Willison'])

    This class exists to solve the irritating problem raised by cgi.parse_qs,
    which returns a list for every key, even though most Web forms submit
    single name-value pairs.
    """
    def __init__(self, key_to_list_mapping=()):
<<<<<<< HEAD
        super(MultiValueDict, self).__init__(key_to_list_mapping)

    def __repr__(self):
        return "<%s: %s>" % (self.__class__.__name__,
                             super(MultiValueDict, self).__repr__())

    def __getitem__(self, key):
        """
        Returns the last data value for this key, or [] if it's an empty list;
        raises KeyError if not found.
        """
        try:
            list_ = super(MultiValueDict, self).__getitem__(key)
        except KeyError:
            raise MultiValueDictKeyError(repr(key))
=======
        super().__init__(key_to_list_mapping)

    def __repr__(self):
        return "<%s: %s>" % (self.__class__.__name__, super().__repr__())

    def __getitem__(self, key):
        """
        Return the last data value for this key, or [] if it's an empty list;
        raise KeyError if not found.
        """
        try:
            list_ = super().__getitem__(key)
        except KeyError:
            raise MultiValueDictKeyError(key)
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        try:
            return list_[-1]
        except IndexError:
            return []

    def __setitem__(self, key, value):
<<<<<<< HEAD
        super(MultiValueDict, self).__setitem__(key, [value])
=======
        super().__setitem__(key, [value])
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435

    def __copy__(self):
        return self.__class__([
            (k, v[:])
            for k, v in self.lists()
        ])

<<<<<<< HEAD
    def __deepcopy__(self, memo=None):
        if memo is None:
            memo = {}
=======
    def __deepcopy__(self, memo):
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        result = self.__class__()
        memo[id(self)] = result
        for key, value in dict.items(self):
            dict.__setitem__(result, copy.deepcopy(key, memo),
                             copy.deepcopy(value, memo))
        return result

    def __getstate__(self):
        obj_dict = self.__dict__.copy()
        obj_dict['_data'] = {k: self._getlist(k) for k in self}
        return obj_dict

    def __setstate__(self, obj_dict):
        data = obj_dict.pop('_data', {})
        for k, v in data.items():
            self.setlist(k, v)
        self.__dict__.update(obj_dict)

    def get(self, key, default=None):
        """
<<<<<<< HEAD
        Returns the last data value for the passed key. If key doesn't exist
        or value is an empty list, then default is returned.
=======
        Return the last data value for the passed key. If key doesn't exist
        or value is an empty list, return `default`.
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        """
        try:
            val = self[key]
        except KeyError:
            return default
        if val == []:
            return default
        return val

    def _getlist(self, key, default=None, force_list=False):
        """
        Return a list of values for the key.

        Used internally to manipulate values list. If force_list is True,
        return a new copy of values.
        """
        try:
<<<<<<< HEAD
            values = super(MultiValueDict, self).__getitem__(key)
=======
            values = super().__getitem__(key)
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        except KeyError:
            if default is None:
                return []
            return default
        else:
            if force_list:
                values = list(values) if values is not None else None
            return values

    def getlist(self, key, default=None):
        """
        Return the list of values for the key. If key doesn't exist, return a
        default value.
        """
        return self._getlist(key, default, force_list=True)

    def setlist(self, key, list_):
<<<<<<< HEAD
        super(MultiValueDict, self).__setitem__(key, list_)
=======
        super().__setitem__(key, list_)
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435

    def setdefault(self, key, default=None):
        if key not in self:
            self[key] = default
            # Do not return default here because __setitem__() may store
            # another value -- QueryDict.__setitem__() does. Look it up.
        return self[key]

    def setlistdefault(self, key, default_list=None):
        if key not in self:
            if default_list is None:
                default_list = []
            self.setlist(key, default_list)
            # Do not return default_list here because setlist() may store
            # another value -- QueryDict.setlist() does. Look it up.
        return self._getlist(key)

    def appendlist(self, key, value):
<<<<<<< HEAD
        """Appends an item to the internal list associated with key."""
        self.setlistdefault(key).append(value)

    def _iteritems(self):
        """
        Yields (key, value) pairs, where value is the last item in the list
=======
        """Append an item to the internal list associated with key."""
        self.setlistdefault(key).append(value)

    def items(self):
        """
        Yield (key, value) pairs, where value is the last item in the list
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        associated with the key.
        """
        for key in self:
            yield key, self[key]

<<<<<<< HEAD
    def _iterlists(self):
        """Yields (key, list) pairs."""
        return six.iteritems(super(MultiValueDict, self))

    def _itervalues(self):
=======
    def lists(self):
        """Yield (key, list) pairs."""
        return iter(super().items())

    def values(self):
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        """Yield the last value on every key list."""
        for key in self:
            yield self[key]

<<<<<<< HEAD
    if six.PY3:
        items = _iteritems
        lists = _iterlists
        values = _itervalues
    else:
        iteritems = _iteritems
        iterlists = _iterlists
        itervalues = _itervalues

        def items(self):
            return list(self.iteritems())

        def lists(self):
            return list(self.iterlists())

        def values(self):
            return list(self.itervalues())

    def copy(self):
        """Returns a shallow copy of this object."""
        return copy.copy(self)

    def update(self, *args, **kwargs):
        """
        update() extends rather than replaces existing key lists.
        Also accepts keyword args.
        """
=======
    def copy(self):
        """Return a shallow copy of this object."""
        return copy.copy(self)

    def update(self, *args, **kwargs):
        """Extend rather than replace existing key lists."""
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        if len(args) > 1:
            raise TypeError("update expected at most 1 arguments, got %d" % len(args))
        if args:
            other_dict = args[0]
            if isinstance(other_dict, MultiValueDict):
                for key, value_list in other_dict.lists():
                    self.setlistdefault(key).extend(value_list)
            else:
                try:
                    for key, value in other_dict.items():
                        self.setlistdefault(key).append(value)
                except TypeError:
                    raise ValueError("MultiValueDict.update() takes either a MultiValueDict or dictionary")
<<<<<<< HEAD
        for key, value in six.iteritems(kwargs):
            self.setlistdefault(key).append(value)

    def dict(self):
        """
        Returns current object as a dict with singular values.
        """
=======
        for key, value in kwargs.items():
            self.setlistdefault(key).append(value)

    def dict(self):
        """Return current object as a dict with singular values."""
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        return {key: self[key] for key in self}


class ImmutableList(tuple):
    """
    A tuple-like object that raises useful errors when it is asked to mutate.

    Example::

        >>> a = ImmutableList(range(5), warning="You cannot mutate this.")
        >>> a[3] = '4'
        Traceback (most recent call last):
            ...
        AttributeError: You cannot mutate this.
    """

<<<<<<< HEAD
    def __new__(cls, *args, **kwargs):
        if 'warning' in kwargs:
            warning = kwargs['warning']
            del kwargs['warning']
        else:
            warning = 'ImmutableList object is immutable.'
=======
    def __new__(cls, *args, warning='ImmutableList object is immutable.', **kwargs):
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        self = tuple.__new__(cls, *args, **kwargs)
        self.warning = warning
        return self

    def complain(self, *wargs, **kwargs):
        if isinstance(self.warning, Exception):
            raise self.warning
        else:
            raise AttributeError(self.warning)

    # All list mutation functions complain.
    __delitem__ = complain
    __delslice__ = complain
    __iadd__ = complain
    __imul__ = complain
    __setitem__ = complain
    __setslice__ = complain
    append = complain
    extend = complain
    insert = complain
    pop = complain
    remove = complain
    sort = complain
    reverse = complain


class DictWrapper(dict):
    """
<<<<<<< HEAD
    Wraps accesses to a dictionary so that certain values (those starting with
=======
    Wrap accesses to a dictionary so that certain values (those starting with
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
    the specified prefix) are passed through a function before being returned.
    The prefix is removed before looking up the real value.

    Used by the SQL construction code to ensure that values are correctly
    quoted before being used.
    """
    def __init__(self, data, func, prefix):
<<<<<<< HEAD
        super(DictWrapper, self).__init__(data)
=======
        super().__init__(data)
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        self.func = func
        self.prefix = prefix

    def __getitem__(self, key):
        """
<<<<<<< HEAD
        Retrieves the real value after stripping the prefix string (if
=======
        Retrieve the real value after stripping the prefix string (if
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        present). If the prefix is present, pass the value through self.func
        before returning, otherwise return the raw value.
        """
        if key.startswith(self.prefix):
            use_func = True
            key = key[len(self.prefix):]
        else:
            use_func = False
<<<<<<< HEAD
        value = super(DictWrapper, self).__getitem__(key)
=======
        value = super().__getitem__(key)
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        if use_func:
            return self.func(value)
        return value
