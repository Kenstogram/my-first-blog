<<<<<<< HEAD
from __future__ import unicode_literals

from django.conf import settings
from django.contrib.messages import constants, utils
from django.utils.encoding import force_text, python_2_unicode_compatible
=======
from django.conf import settings
from django.contrib.messages import constants, utils
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435

LEVEL_TAGS = utils.get_level_tags()


<<<<<<< HEAD
@python_2_unicode_compatible
class Message(object):
    """
    Represents an actual message that can be stored in any of the supported
=======
class Message:
    """
    Represent an actual message that can be stored in any of the supported
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
    storage classes (typically session- or cookie-based) and rendered in a view
    or template.
    """

    def __init__(self, level, message, extra_tags=None):
        self.level = int(level)
        self.message = message
        self.extra_tags = extra_tags

    def _prepare(self):
        """
<<<<<<< HEAD
        Prepares the message for serialization by forcing the ``message``
        and ``extra_tags`` to unicode in case they are lazy translations.

        Known "safe" types (None, int, etc.) are not converted (see Django's
        ``force_text`` implementation for details).
        """
        self.message = force_text(self.message, strings_only=True)
        self.extra_tags = force_text(self.extra_tags, strings_only=True)
=======
        Prepare the message for serialization by forcing the ``message``
        and ``extra_tags`` to str in case they are lazy translations.
        """
        self.message = str(self.message)
        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435

    def __eq__(self, other):
        return isinstance(other, Message) and self.level == other.level and \
            self.message == other.message

    def __str__(self):
<<<<<<< HEAD
        return force_text(self.message)

    @property
    def tags(self):
        extra_tags = force_text(self.extra_tags, strings_only=True)
        if extra_tags and self.level_tag:
            return ' '.join([extra_tags, self.level_tag])
        elif extra_tags:
            return extra_tags
        elif self.level_tag:
            return self.level_tag
        return ''

    @property
    def level_tag(self):
        return force_text(LEVEL_TAGS.get(self.level, ''), strings_only=True)


class BaseStorage(object):
=======
        return str(self.message)

    @property
    def tags(self):
        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)

    @property
    def level_tag(self):
        return LEVEL_TAGS.get(self.level, '')


class BaseStorage:
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
    """
    This is the base backend for temporary message storage.

    This is not a complete class; to be a usable storage backend, it must be
    subclassed and the two methods ``_get`` and ``_store`` overridden.
    """

    def __init__(self, request, *args, **kwargs):
        self.request = request
        self._queued_messages = []
        self.used = False
        self.added_new = False
<<<<<<< HEAD
        super(BaseStorage, self).__init__(*args, **kwargs)
=======
        super().__init__(*args, **kwargs)
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435

    def __len__(self):
        return len(self._loaded_messages) + len(self._queued_messages)

    def __iter__(self):
        self.used = True
        if self._queued_messages:
            self._loaded_messages.extend(self._queued_messages)
            self._queued_messages = []
        return iter(self._loaded_messages)

    def __contains__(self, item):
        return item in self._loaded_messages or item in self._queued_messages

    @property
    def _loaded_messages(self):
        """
<<<<<<< HEAD
        Returns a list of loaded messages, retrieving them first if they have
=======
        Return a list of loaded messages, retrieving them first if they have
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        not been loaded yet.
        """
        if not hasattr(self, '_loaded_data'):
            messages, all_retrieved = self._get()
            self._loaded_data = messages or []
        return self._loaded_data

    def _get(self, *args, **kwargs):
        """
<<<<<<< HEAD
        Retrieves a list of stored messages. Returns a tuple of the messages
=======
        Retrieve a list of stored messages. Return a tuple of the messages
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        and a flag indicating whether or not all the messages originally
        intended to be stored in this storage were, in fact, stored and
        retrieved; e.g., ``(messages, all_retrieved)``.

        **This method must be implemented by a subclass.**

        If it is possible to tell if the backend was not used (as opposed to
        just containing no messages) then ``None`` should be returned in
        place of ``messages``.
        """
        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')

    def _store(self, messages, response, *args, **kwargs):
        """
<<<<<<< HEAD
        Stores a list of messages, returning a list of any messages which could
=======
        Store a list of messages and return a list of any messages which could
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        not be stored.

        One type of object must be able to be stored, ``Message``.

        **This method must be implemented by a subclass.**
        """
        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')

    def _prepare_messages(self, messages):
        """
<<<<<<< HEAD
        Prepares a list of messages for storage.
=======
        Prepare a list of messages for storage.
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        """
        for message in messages:
            message._prepare()

    def update(self, response):
        """
<<<<<<< HEAD
        Stores all unread messages.

        If the backend has yet to be iterated, previously stored messages will
        be stored again. Otherwise, only messages added after the last
        iteration will be stored.
=======
        Store all unread messages.

        If the backend has yet to be iterated, store previously stored messages
        again. Otherwise, only store messages added after the last iteration.
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435
        """
        self._prepare_messages(self._queued_messages)
        if self.used:
            return self._store(self._queued_messages, response)
        elif self.added_new:
            messages = self._loaded_messages + self._queued_messages
            return self._store(messages, response)

    def add(self, level, message, extra_tags=''):
        """
<<<<<<< HEAD
        Queues a message to be stored.
=======
        Queue a message to be stored.
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435

        The message is only queued if it contained something and its level is
        not less than the recording level (``self.level``).
        """
        if not message:
            return
        # Check that the message level is not less than the recording level.
        level = int(level)
        if level < self.level:
            return
        # Add the message.
        self.added_new = True
        message = Message(level, message, extra_tags=extra_tags)
        self._queued_messages.append(message)

    def _get_level(self):
        """
<<<<<<< HEAD
        Returns the minimum recorded level.
=======
        Return the minimum recorded level.
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435

        The default level is the ``MESSAGE_LEVEL`` setting. If this is
        not found, the ``INFO`` level is used.
        """
        if not hasattr(self, '_level'):
            self._level = getattr(settings, 'MESSAGE_LEVEL', constants.INFO)
        return self._level

    def _set_level(self, value=None):
        """
<<<<<<< HEAD
        Sets a custom minimum recorded level.
=======
        Set a custom minimum recorded level.
>>>>>>> 37c99181c9a6b95433d60f8c8ef9af5731096435

        If set to ``None``, the default level will be used (see the
        ``_get_level`` method).
        """
        if value is None and hasattr(self, '_level'):
            del self._level
        else:
            self._level = int(value)

    level = property(_get_level, _set_level, _set_level)
